//
//  AppDelegate.m
//  ChromatismDemo
//
//  Created by Anviking on 2013-07-31.
//  Copyright (c) 2013 Anviking. All rights reserved.
//

#import "AppDelegate.h"
#import <Chromatism/Chromatism.h>

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    
    JLTextViewController *viewController = [[JLTextViewController alloc] init];
    UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:viewController];
    viewController.title = @"Chromatism";
    
    self.window.rootViewController = navigationController;
    self.window.backgroundColor = [UIColor whiteColor];
    [self.window makeKeyAndVisible];
    return YES;
}

- (void)applicationWillResignActive:(UIApplication *)application
{
    // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
    // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
}

- (void)applicationDidEnterBackground:(UIApplication *)application
{
    // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later. 
    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
}

/*
- (void)applicationWillEnterForeground:(UIApplication *)application
{
    // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.
}

- (void)applicationDidBecomeActive:(UIApplication *)application
{
    // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
}

- (void)applicationWillTerminate:(UIApplication *)application
{
    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
}
*/

@end

//
//  Tokenizer.m
//  iGitpad
//
//  Created by Johannes Lund on 2012-11-24.
//
//

//  This file builds upon the work of Kristian Kraljic
//
//  RegexHighlightView.m
//  Simple Objective-C Syntax Highlighter
//
//  Created by Kristian Kraljic on 30/08/12.
//  Copyright (c) 2012 Kristian Kraljic (dikrypt.com, ksquared.de). All rights reserved.
//
//  Permission is hereby granted, free of charge, to any person
//  obtaining a copy of this software and associated documentation
//  files (the "Software"), to deal in the Software without
//  restriction, including without limitation the rights to use,
//  copy, modify, merge, publish, distribute, sublicense, and/or
//  sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following
//  conditions:
//
//  The above copyright notice and this permission notice shall be
//  included in all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//  OTHER DEALINGS IN THE SOFTWARE.
//

#import "JLTokenizer.h"
#import "JLTextViewController.h" 
#import "JLScope.h"
#import "JLTokenPattern.h"
#import "Chromatism+Internal.h"

@interface JLTokenizer ()
@property (nonatomic, strong) NSOperationQueue *operationQueue;
@end

@implementation JLTokenizer

#pragma mark - Setup

- (id)init
{
    self = [super init];
    if (self) {
        self.operationQueue = [[NSOperationQueue alloc] init];
        self.operationQueue.maxConcurrentOperationCount = 1;
    }
    return self;
}

#pragma mark - NSTextStorageDelegate

- (void)textStorage:(NSTextStorage *)textStorage willProcessEditing:(NSTextStorageEditActions)editedMask range:(NSRange)editedRange changeInLength:(NSInteger)delta
{
    
}

- (void)textStorage:(NSTextStorage *)textStorage didProcessEditing:(NSTextStorageEditActions)editedMask range:(NSRange)editedRange changeInLength:(NSInteger)delta
{
    if (textStorage.editedMask == NSTextStorageEditedAttributes) return;
    [self tokenizeTextStorage:textStorage withScope:[self documentScopeForTokenizingTextStorage:textStorage inRange:editedRange]];
}

#pragma mark - NSLayoutManager delegeate

- (CGFloat)layoutManager:(NSLayoutManager *)layoutManager paragraphSpacingBeforeGlyphAtIndex:(NSUInteger)glyphIndex withProposedLineFragmentRect:(CGRect)rect
{
    return 0;
}

- (BOOL)layoutManager:(NSLayoutManager *)layoutManager shouldBreakLineByWordBeforeCharacterAtIndex:(NSUInteger)charIndex
{
    unichar character = [layoutManager.textStorage.string characterAtIndex:charIndex];
    if (character == '*') return NO;
    return YES;
}

#pragma mark - UITextViewDelegate

- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text
{
    if (![text isEqualToString:@"\n"]) return YES; // Something else than return
    
    // Return has been pressed, start the new line with as many tabs or white spaces as the previous one.
    NSString *prefixString = [@"\n" stringByAppendingString:[self prefixStringFromRange:range inTextView:textView]];
    
    unichar previousCharacter = [textView.text characterAtIndex:range.location - 1];
    if (self.intendator && [self.intendator respondsToSelector:@selector(indentationActionAfterReplacingTextInRange:replacementText:previousCharacter:textView:)]) {
        switch ([self indentationActionAfterReplacingTextInRange:range replacementText:text previousCharacter:previousCharacter textView:textView]) {
            case JLIndentationActionIncrease:
                prefixString = [prefixString stringByAppendingString:@"    "];
                break;
            case JLIndentationActionDecrease:
                if ([[prefixString substringFromIndex:prefixString.length - 4] isEqualToString:@"    "]) {
                    prefixString = [prefixString substringToIndex:prefixString.length - 4];
                }
                else if ([[prefixString substringFromIndex:prefixString.length - 1] isEqualToString:@"\t"]) {
                    prefixString = [prefixString substringToIndex:prefixString.length - 1];
                }
                break;
            case JLIndentationActionNone:
                break;
        }
    }

    
    [textView replaceRange:[self rangeWithRange:range inTextView:textView] withText:prefixString];
    return NO;
}


#pragma mark - Tokenizing

- (void)refreshTokenizationOfTextStorage:(NSTextStorage *)textStorage;
{
    [self tokenizeTextStorage:textStorage withScope:[self documentScopeForTokenizingTextStorage:textStorage inRange:NSMakeRange(0, textStorage.length)]];
}

- (JLScope *)documentScopeForTokenizingTextStorage:(NSTextStorage *)textStorage inRange:(NSRange)range
{
    JLScope *documentScope = [JLScope new];
    JLScope *lineScope = [JLScope new];
    
    [self prepareDocumentScope:documentScope];
    [self prepareLineScope:lineScope];
    
    [documentScope addSubscope:lineScope];
    
    [self clearColorAttributesInRange:range textStorage:textStorage];
    
    [documentScope setTextStorage:textStorage];
    [documentScope setSet:[NSMutableIndexSet indexSetWithIndexesInRange:NSMakeRange(0, textStorage.length)]];
    [lineScope setSet:[NSMutableIndexSet indexSetWithIndexesInRange:[textStorage.string lineRangeForRange:range]]];
    
    return documentScope;
}

- (void)tokenizeTextStorage:(NSTextStorage *)textStorage withScope:(JLScope *)scope
{
    //[textStorage beginEditing];
    [self.operationQueue addOperations:[[scope recursiveSubscopes] allObjects] waitUntilFinished:YES];
    //[textStorage endEditing];
}

#pragma mark - Synchronous Tokenization

- (void)tokenizeAttributedString:(NSMutableAttributedString *)string
{
    JLScope *scope = [self documentScopeForTokenizingTextStorage:(NSTextStorage *)string inRange:NSMakeRange(0, string.length)];
    [self.operationQueue addOperations:[[scope recursiveSubscopes] allObjects] waitUntilFinished:YES];
}

#pragma mark - Setup Token Patterns

- (void)prepareDocumentScope:(JLScope *)documentScope
{

}

- (void)prepareLineScope:(JLScope *)lineScope
{

}


#pragma mark - Symbolication

/*
- (void)symbolicate
{
    [self.scopes[PROJECT_CLASS_NAMES] setPattern:[NSString stringWithFormat:@"\\b(%@)\\b", [[self symbolsWithPattern:@"^@implementation (\\w+)" captureGroup:1] componentsJoinedByString:@"|"]]];
    [self.scopes[PROJECT_METHOD_NAMES] setPattern:[NSString stringWithFormat:@"\\b(%@)\\b", [[self symbolsWithPattern:@"^@property \\(.*?\\)\\s*\\w+[\\s*]+(\\w+);" captureGroup:1] componentsJoinedByString:@"|"]]];
}
*/

#pragma mark - Helpers

- (JLTokenPattern *)addToken:(NSString *)type withPattern:(NSString *)pattern andScope:(JLScope *)scope
{

    NSParameterAssert(type);
    NSParameterAssert(pattern);
    NSParameterAssert(scope);
    
    JLTokenPattern *token = [JLTokenPattern token:type withPattern:pattern andScope:scope];
    token.color = self.colors[type];
    
    return token;
}

- (JLTokenPattern *)addToken:(NSString *)type withKeywords:(NSString *)keywords andScope:(JLScope *)scope
{
    NSString *pattern = [NSString stringWithFormat:@"\\b(%@)\\b", [[keywords componentsSeparatedByString:@" "] componentsJoinedByString:@"|"]];
    return [self addToken:type withPattern:pattern andScope:scope];
}

- (NSMutableArray *)symbolsWithPattern:(NSString *)pattern captureGroup:(int)group textStorage:(NSTextStorage *)textStorage
{
    NSMutableArray *array = [NSMutableArray array];
    NSError *error = nil;
    NSRegularExpression *expression = [NSRegularExpression regularExpressionWithPattern:pattern options:NSRegularExpressionAnchorsMatchLines error:&error];
    [expression enumerateMatchesInString:textStorage.string options:0 range:NSMakeRange(0, textStorage.length) usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOL *stop) {
        [array addObject:[textStorage.string substringWithRange:[result rangeAtIndex:group]]];
    }];
    NSAssert(!error, @"%@",error);
    return array;
}

#pragma mark - Indentation

- (id <JLIndentation>)intendator
{
    if (!_intendator) {
        _intendator = self;
    }
    return _intendator;
}

- (JLIndentationAction)indentationActionAfterReplacingTextInRange:(NSRange)range replacementText:(NSString *)text previousCharacter:(unichar)character textView:(UITextView *)textView;
{
    if (character == '{') {
        return JLIndentationActionIncrease;
    } else if (character == '}') {
        return JLIndentationActionDecrease;
    } else {
        return JLIndentationActionNone;
    }
}

#pragma mark - Helpers

- (UITextRange *)rangeWithRange:(NSRange)range inTextView:(UITextView *)textView
{
    UITextPosition *beginning = textView.beginningOfDocument;
    UITextPosition *start = [textView positionFromPosition:beginning offset:range.location];
    UITextPosition *stop = [textView positionFromPosition:start offset:range.length];
    
    return [textView textRangeFromPosition:start toPosition:stop];
}

- (void)clearColorAttributesInRange:(NSRange)range textStorage:(NSTextStorage *)storage;
{
    [storage removeAttribute:NSForegroundColorAttributeName range:range];
    [storage addAttribute:NSForegroundColorAttributeName value:self.colors[JLTokenTypeText] range:range];
}

- (NSString *)prefixStringFromRange:(NSRange)range inTextView:(UITextView *)textView
{
    NSRange lineRange = [textView.text lineRangeForRange:range];
    NSRange prefixRange = [textView.text rangeOfString:@"[\\t| ]*" options:NSRegularExpressionSearch range:lineRange];
    return [textView.text substringWithRange:prefixRange];
}

@end


//
//  JLTextViewController.m
//  iGitpad
//
//  Created by Johannes Lund on 2013-06-13.
//  Copyright (c) 2013 Johannes Lund
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of
//  this software and associated documentation files (the "Software"), to deal in
//  the Software without restriction, including without limitation the rights to
//  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
//  the Software, and to permit persons to whom the Software is furnished to do so,
//  subject to the following conditions:

//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.

//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
//  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
//  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
//  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.//

#import "JLTextViewController.h"
#import "JLTokenizer.h"
#import "JLTokenizer.h"
#import "JLTextView.h"

@interface JLTextViewController ()
/// Only set from -initWithText: and directly set to nil in -loadView
@property (nonatomic, strong) NSString *defaultText;
@end

@implementation JLTextViewController

- (instancetype)initWithText:(NSString *)text
{
    self = [super init];
    if (self) {
        _defaultText = text;
    }
    return self;
}

- (void)loadView
{
    self.view = self.textView;
}

- (JLTextView *)textView
{
    if (!_textView) {
        JLTextView *textView = [[JLTextView alloc] initWithFrame:CGRectZero];
        textView.autoresizingMask = UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth;
        
        if (self.defaultText) {
            textView.text = self.defaultText;
            self.defaultText = nil;
        }
        
        [self setTextView:textView];
    }
    return _textView;
}
/*
- (JLTokenizer *)tokenizer
{
    return self.textView.syntaxTokenizer;
}
*/
/*
- (void)viewDidLoad
{
    [super viewDidLoad];
    
    self.view.backgroundColor = self.textView.backgroundColor;
    self.navigationController.navigationBar.translucent = TRUE;
    
    [self registerForKeyboardNotifications];
}
*/

/*
- (void)didReceiveMemoryWarning
{/*
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
    */
}
*/

#pragma mark - Content Insets and Keyboard

// Call this method somewhere in your view controller setup code.
- (void)registerForKeyboardNotifications
{
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(keyboardWasShown:)
                                                 name:UIKeyboardDidShowNotification object:nil];
    
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(keyboardWillBeHidden:)
                                                 name:UIKeyboardWillHideNotification object:nil];
    
}

// Called when the UIKeyboardDidShowNotification is sent.
- (void)keyboardWasShown:(NSNotification *)notification
{
    NSDictionary* info = [notification userInfo];
    UIScrollView *scrollView = self.textView;
    CGSize kbSize = [[info objectForKey:UIKeyboardFrameBeginUserInfoKey] CGRectValue].size;
    
    UIEdgeInsets contentInsets = scrollView.contentInset;
    contentInsets.bottom = kbSize.height;
    scrollView.contentInset = contentInsets;
    scrollView.scrollIndicatorInsets = contentInsets;
    
    CGPoint point = [self.textView caretRectForPosition:self.textView.selectedTextRange.start].origin;
    point.y = MIN(point.y, self.textView.frame.size.height - kbSize.height);
    
    CGRect aRect = self.view.frame;
    aRect.size.height -= kbSize.height;
    if (!CGRectContainsPoint(aRect, point) ) {
        
        CGRect rect = CGRectMake(point.x, point.y, 1, 1);
        rect.size.height = kbSize.height;
        rect.origin.y += kbSize.height;
        [self.textView scrollRectToVisible:rect animated:YES];
    }
}

// Called when the UIKeyboardWillHideNotification is sent
- (void)keyboardWillBeHidden:(NSNotification *)notification
{
    UIScrollView *scrollView = self.textView;
    UIEdgeInsets contentInsets = scrollView.contentInset;
    contentInsets.bottom = 0;
    scrollView.contentInset = contentInsets;
    scrollView.scrollIndicatorInsets = contentInsets;
    scrollView.contentInset = contentInsets;
    scrollView.scrollIndicatorInsets = contentInsets;
}

@end

//
//  JLTextViewController.h
//  iGitpad
//
//  Created by Johannes Lund on 2013-06-13.
//  Copyright (c) 2013 Johannes Lund
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of
//  this software and associated documentation files (the "Software"), to deal in
//  the Software without restriction, including without limitation the rights to
//  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
//  the Software, and to permit persons to whom the Software is furnished to do so,
//  subject to the following conditions:

//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.

//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
//  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
//  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
//  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.//

/*
#import <UIKit/UIKit.h>

@class JLTokenizer, JLTextView;

@interface JLTextViewController : UIViewController

- (instancetype)initWithText:(NSString *)text;

@property (nonatomic, strong) IBOutlet JLTextView *textView;

// Convenience property for self.textView.syntaxTokenizer
@property (nonatomic, weak, readonly) JLTokenizer *tokenizer;
@end
*/

//
//  AppDelegate.m
//  ChromatismDemo
//
//  Created by Anviking on 2013-07-31.
//  Copyright (c) 2013 Anviking. All rights reserved.
//

#import "AppDelegate.h"
#import <Chromatism/Chromatism.h>

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    
    JLTextViewController *viewController = [[JLTextViewController alloc] init];
    UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:viewController];
    viewController.title = @"Chromatism";
    
    self.window.rootViewController = navigationController;
    self.window.backgroundColor = [UIColor whiteColor];
    [self.window makeKeyAndVisible];
    return YES;
}

- (void)applicationWillResignActive:(UIApplication *)application
{
    // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
    // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
}

- (void)applicationDidEnterBackground:(UIApplication *)application
{
    // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later. 
    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
}

/*
- (void)applicationWillEnterForeground:(UIApplication *)application
{
    // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.
}

- (void)applicationDidBecomeActive:(UIApplication *)application
{
    // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
}

- (void)applicationWillTerminate:(UIApplication *)application
{
    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
}
*/

@end

//
//  Tokenizer.m
//  iGitpad
//
//  Created by Johannes Lund on 2012-11-24.
//
//

//  This file builds upon the work of Kristian Kraljic
//
//  RegexHighlightView.m
//  Simple Objective-C Syntax Highlighter
//
//  Created by Kristian Kraljic on 30/08/12.
//  Copyright (c) 2012 Kristian Kraljic (dikrypt.com, ksquared.de). All rights reserved.
//
//  Permission is hereby granted, free of charge, to any person
//  obtaining a copy of this software and associated documentation
//  files (the "Software"), to deal in the Software without
//  restriction, including without limitation the rights to use,
//  copy, modify, merge, publish, distribute, sublicense, and/or
//  sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following
//  conditions:
//
//  The above copyright notice and this permission notice shall be
//  included in all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//  OTHER DEALINGS IN THE SOFTWARE.
//

#import "JLTokenizer.h"
#import "JLTextViewController.h" 
#import "JLScope.h"
#import "JLTokenPattern.h"
#import "Chromatism+Internal.h"

@interface JLTokenizer ()
@property (nonatomic, strong) NSOperationQueue *operationQueue;
@end

@implementation JLTokenizer

#pragma mark - Setup

- (id)init
{
    self = [super init];
    if (self) {
        self.operationQueue = [[NSOperationQueue alloc] init];
        self.operationQueue.maxConcurrentOperationCount = 1;
    }
    return self;
}

#pragma mark - NSTextStorageDelegate

- (void)textStorage:(NSTextStorage *)textStorage willProcessEditing:(NSTextStorageEditActions)editedMask range:(NSRange)editedRange changeInLength:(NSInteger)delta
{
    
}

- (void)textStorage:(NSTextStorage *)textStorage didProcessEditing:(NSTextStorageEditActions)editedMask range:(NSRange)editedRange changeInLength:(NSInteger)delta
{
    if (textStorage.editedMask == NSTextStorageEditedAttributes) return;
    [self tokenizeTextStorage:textStorage withScope:[self documentScopeForTokenizingTextStorage:textStorage inRange:editedRange]];
}

#pragma mark - NSLayoutManager delegeate

- (CGFloat)layoutManager:(NSLayoutManager *)layoutManager paragraphSpacingBeforeGlyphAtIndex:(NSUInteger)glyphIndex withProposedLineFragmentRect:(CGRect)rect
{
    return 0;
}

- (BOOL)layoutManager:(NSLayoutManager *)layoutManager shouldBreakLineByWordBeforeCharacterAtIndex:(NSUInteger)charIndex
{
    unichar character = [layoutManager.textStorage.string characterAtIndex:charIndex];
    if (character == '*') return NO;
    return YES;
}

#pragma mark - UITextViewDelegate

- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text
{
    if (![text isEqualToString:@"\n"]) return YES; // Something else than return
    
    // Return has been pressed, start the new line with as many tabs or white spaces as the previous one.
    NSString *prefixString = [@"\n" stringByAppendingString:[self prefixStringFromRange:range inTextView:textView]];
    
    unichar previousCharacter = [textView.text characterAtIndex:range.location - 1];
    if (self.intendator && [self.intendator respondsToSelector:@selector(indentationActionAfterReplacingTextInRange:replacementText:previousCharacter:textView:)]) {
        switch ([self indentationActionAfterReplacingTextInRange:range replacementText:text previousCharacter:previousCharacter textView:textView]) {
            case JLIndentationActionIncrease:
                prefixString = [prefixString stringByAppendingString:@"    "];
                break;
            case JLIndentationActionDecrease:
                if ([[prefixString substringFromIndex:prefixString.length - 4] isEqualToString:@"    "]) {
                    prefixString = [prefixString substringToIndex:prefixString.length - 4];
                }
                else if ([[prefixString substringFromIndex:prefixString.length - 1] isEqualToString:@"\t"]) {
                    prefixString = [prefixString substringToIndex:prefixString.length - 1];
                }
                break;
            case JLIndentationActionNone:
                break;
        }
    }

    
    [textView replaceRange:[self rangeWithRange:range inTextView:textView] withText:prefixString];
    return NO;
}


#pragma mark - Tokenizing

- (void)refreshTokenizationOfTextStorage:(NSTextStorage *)textStorage;
{
    [self tokenizeTextStorage:textStorage withScope:[self documentScopeForTokenizingTextStorage:textStorage inRange:NSMakeRange(0, textStorage.length)]];
}

- (JLScope *)documentScopeForTokenizingTextStorage:(NSTextStorage *)textStorage inRange:(NSRange)range
{
    JLScope *documentScope = [JLScope new];
    JLScope *lineScope = [JLScope new];
    
    [self prepareDocumentScope:documentScope];
    [self prepareLineScope:lineScope];
    
    [documentScope addSubscope:lineScope];
    
    [self clearColorAttributesInRange:range textStorage:textStorage];
    
    [documentScope setTextStorage:textStorage];
    [documentScope setSet:[NSMutableIndexSet indexSetWithIndexesInRange:NSMakeRange(0, textStorage.length)]];
    [lineScope setSet:[NSMutableIndexSet indexSetWithIndexesInRange:[textStorage.string lineRangeForRange:range]]];
    
    return documentScope;
}

- (void)tokenizeTextStorage:(NSTextStorage *)textStorage withScope:(JLScope *)scope
{
    //[textStorage beginEditing];
    [self.operationQueue addOperations:[[scope recursiveSubscopes] allObjects] waitUntilFinished:YES];
    //[textStorage endEditing];
}

#pragma mark - Synchronous Tokenization

- (void)tokenizeAttributedString:(NSMutableAttributedString *)string
{
    JLScope *scope = [self documentScopeForTokenizingTextStorage:(NSTextStorage *)string inRange:NSMakeRange(0, string.length)];
    [self.operationQueue addOperations:[[scope recursiveSubscopes] allObjects] waitUntilFinished:YES];
}

#pragma mark - Setup Token Patterns

- (void)prepareDocumentScope:(JLScope *)documentScope
{

}

- (void)prepareLineScope:(JLScope *)lineScope
{

}


#pragma mark - Symbolication

/*
- (void)symbolicate
{
    [self.scopes[PROJECT_CLASS_NAMES] setPattern:[NSString stringWithFormat:@"\\b(%@)\\b", [[self symbolsWithPattern:@"^@implementation (\\w+)" captureGroup:1] componentsJoinedByString:@"|"]]];
    [self.scopes[PROJECT_METHOD_NAMES] setPattern:[NSString stringWithFormat:@"\\b(%@)\\b", [[self symbolsWithPattern:@"^@property \\(.*?\\)\\s*\\w+[\\s*]+(\\w+);" captureGroup:1] componentsJoinedByString:@"|"]]];
}
*/

#pragma mark - Helpers

- (JLTokenPattern *)addToken:(NSString *)type withPattern:(NSString *)pattern andScope:(JLScope *)scope
{

    NSParameterAssert(type);
    NSParameterAssert(pattern);
    NSParameterAssert(scope);
    
    JLTokenPattern *token = [JLTokenPattern token:type withPattern:pattern andScope:scope];
    token.color = self.colors[type];
    
    return token;
}

- (JLTokenPattern *)addToken:(NSString *)type withKeywords:(NSString *)keywords andScope:(JLScope *)scope
{
    NSString *pattern = [NSString stringWithFormat:@"\\b(%@)\\b", [[keywords componentsSeparatedByString:@" "] componentsJoinedByString:@"|"]];
    return [self addToken:type withPattern:pattern andScope:scope];
}

- (NSMutableArray *)symbolsWithPattern:(NSString *)pattern captureGroup:(int)group textStorage:(NSTextStorage *)textStorage
{
    NSMutableArray *array = [NSMutableArray array];
    NSError *error = nil;
    NSRegularExpression *expression = [NSRegularExpression regularExpressionWithPattern:pattern options:NSRegularExpressionAnchorsMatchLines error:&error];
    [expression enumerateMatchesInString:textStorage.string options:0 range:NSMakeRange(0, textStorage.length) usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOL *stop) {
        [array addObject:[textStorage.string substringWithRange:[result rangeAtIndex:group]]];
    }];
    NSAssert(!error, @"%@",error);
    return array;
}

#pragma mark - Indentation

- (id <JLIndentation>)intendator
{
    if (!_intendator) {
        _intendator = self;
    }
    return _intendator;
}

- (JLIndentationAction)indentationActionAfterReplacingTextInRange:(NSRange)range replacementText:(NSString *)text previousCharacter:(unichar)character textView:(UITextView *)textView;
{
    if (character == '{') {
        return JLIndentationActionIncrease;
    } else if (character == '}') {
        return JLIndentationActionDecrease;
    } else {
        return JLIndentationActionNone;
    }
}

#pragma mark - Helpers

- (UITextRange *)rangeWithRange:(NSRange)range inTextView:(UITextView *)textView
{
    UITextPosition *beginning = textView.beginningOfDocument;
    UITextPosition *start = [textView positionFromPosition:beginning offset:range.location];
    UITextPosition *stop = [textView positionFromPosition:start offset:range.length];
    
    return [textView textRangeFromPosition:start toPosition:stop];
}

- (void)clearColorAttributesInRange:(NSRange)range textStorage:(NSTextStorage *)storage;
{
    [storage removeAttribute:NSForegroundColorAttributeName range:range];
    [storage addAttribute:NSForegroundColorAttributeName value:self.colors[JLTokenTypeText] range:range];
}

- (NSString *)prefixStringFromRange:(NSRange)range inTextView:(UITextView *)textView
{
    NSRange lineRange = [textView.text lineRangeForRange:range];
    NSRange prefixRange = [textView.text rangeOfString:@"[\\t| ]*" options:NSRegularExpressionSearch range:lineRange];
    return [textView.text substringWithRange:prefixRange];
}

@end


//
//  JLTextViewController.m
//  iGitpad
//
//  Created by Johannes Lund on 2013-06-13.
//  Copyright (c) 2013 Johannes Lund
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of
//  this software and associated documentation files (the "Software"), to deal in
//  the Software without restriction, including without limitation the rights to
//  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
//  the Software, and to permit persons to whom the Software is furnished to do so,
//  subject to the following conditions:

//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.

//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
//  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
//  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
//  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.//

#import "JLTextViewController.h"
#import "JLTokenizer.h"
#import "JLTokenizer.h"
#import "JLTextView.h"

@interface JLTextViewController ()
/// Only set from -initWithText: and directly set to nil in -loadView
@property (nonatomic, strong) NSString *defaultText;
@end

@implementation JLTextViewController

- (instancetype)initWithText:(NSString *)text
{
    self = [super init];
    if (self) {
        _defaultText = text;
    }
    return self;
}

- (void)loadView
{
    self.view = self.textView;
}

- (JLTextView *)textView
{
    if (!_textView) {
        JLTextView *textView = [[JLTextView alloc] initWithFrame:CGRectZero];
        textView.autoresizingMask = UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth;
        
        if (self.defaultText) {
            textView.text = self.defaultText;
            self.defaultText = nil;
        }
        
        [self setTextView:textView];
    }
    return _textView;
}
/*
- (JLTokenizer *)tokenizer
{
    return self.textView.syntaxTokenizer;
}
*/
/*
- (void)viewDidLoad
{
    [super viewDidLoad];
    
    self.view.backgroundColor = self.textView.backgroundColor;
    self.navigationController.navigationBar.translucent = TRUE;
    
    [self registerForKeyboardNotifications];
}
*/

/*
- (void)didReceiveMemoryWarning
{/*
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
    */
}
*/

#pragma mark - Content Insets and Keyboard

// Call this method somewhere in your view controller setup code.
- (void)registerForKeyboardNotifications
{
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(keyboardWasShown:)
                                                 name:UIKeyboardDidShowNotification object:nil];
    
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(keyboardWillBeHidden:)
                                                 name:UIKeyboardWillHideNotification object:nil];
    
}

// Called when the UIKeyboardDidShowNotification is sent.
- (void)keyboardWasShown:(NSNotification *)notification
{
    NSDictionary* info = [notification userInfo];
    UIScrollView *scrollView = self.textView;
    CGSize kbSize = [[info objectForKey:UIKeyboardFrameBeginUserInfoKey] CGRectValue].size;
    
    UIEdgeInsets contentInsets = scrollView.contentInset;
    contentInsets.bottom = kbSize.height;
    scrollView.contentInset = contentInsets;
    scrollView.scrollIndicatorInsets = contentInsets;
    
    CGPoint point = [self.textView caretRectForPosition:self.textView.selectedTextRange.start].origin;
    point.y = MIN(point.y, self.textView.frame.size.height - kbSize.height);
    
    CGRect aRect = self.view.frame;
    aRect.size.height -= kbSize.height;
    if (!CGRectContainsPoint(aRect, point) ) {
        
        CGRect rect = CGRectMake(point.x, point.y, 1, 1);
        rect.size.height = kbSize.height;
        rect.origin.y += kbSize.height;
        [self.textView scrollRectToVisible:rect animated:YES];
    }
}

// Called when the UIKeyboardWillHideNotification is sent
- (void)keyboardWillBeHidden:(NSNotification *)notification
{
    UIScrollView *scrollView = self.textView;
    UIEdgeInsets contentInsets = scrollView.contentInset;
    contentInsets.bottom = 0;
    scrollView.contentInset = contentInsets;
    scrollView.scrollIndicatorInsets = contentInsets;
    scrollView.contentInset = contentInsets;
    scrollView.scrollIndicatorInsets = contentInsets;
}

@end

//
//  JLTextViewController.h
//  iGitpad
//
//  Created by Johannes Lund on 2013-06-13.
//  Copyright (c) 2013 Johannes Lund
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of
//  this software and associated documentation files (the "Software"), to deal in
//  the Software without restriction, including without limitation the rights to
//  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
//  the Software, and to permit persons to whom the Software is furnished to do so,
//  subject to the following conditions:

//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.

//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
//  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
//  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
//  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.//

/*
#import <UIKit/UIKit.h>

@class JLTokenizer, JLTextView;

@interface JLTextViewController : UIViewController

- (instancetype)initWithText:(NSString *)text;

@property (nonatomic, strong) IBOutlet JLTextView *textView;

// Convenience property for self.textView.syntaxTokenizer
@property (nonatomic, weak, readonly) JLTokenizer *tokenizer;
@end
*/

#import "helpers.h"
void new_application(lua_State* L, pid_t pid);

#define hydra_window(L, idx) *((AXUIElementRef*)luaL_checkudata(L, idx, "window"))

static int window_gc(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    CFRelease(win);
    return 0;
}

static int window_eq(lua_State* L) {
    AXUIElementRef winA = hydra_window(L, 1);
    AXUIElementRef winB = hydra_window(L, 2);
    lua_pushboolean(L, CFEqual(winA, winB));
    return 1;
}

extern AXError _AXUIElementGetWindow(AXUIElementRef, CGWindowID* out);
NSWindow* hydra_nswindow_for_accessibility_window(AXUIElementRef win) {
    CGWindowID winid;
    AXError err = _AXUIElementGetWindow(win, &winid);
    if (err) return nil;
    
    for (NSWindow* window in [NSApp windows]) {
        if ([window windowNumber] == winid)
            return window;
    }
    
    return nil;
}

void new_window(lua_State* L, AXUIElementRef win) {
    AXUIElementRef* winptr = lua_newuserdata(L, sizeof(AXUIElementRef));
    *winptr = win;
    
    luaL_getmetatable(L, "window");
    lua_setmetatable(L, -2);
    
    lua_newtable(L);
    lua_setuservalue(L, -2);
}

static AXUIElementRef system_wide_element() {
    static AXUIElementRef element;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        element = AXUIElementCreateSystemWide();
    });
    return element;
}

/// window.focusedwindow() -> window
/// Returns the focused window, or nil.
static int window_focusedwindow(lua_State* L) {
    CFTypeRef app;
    AXUIElementCopyAttributeValue(system_wide_element(), kAXFocusedApplicationAttribute, &app);
    
    if (app) {
        CFTypeRef win;
        AXError result = AXUIElementCopyAttributeValue(app, (CFStringRef)NSAccessibilityFocusedWindowAttribute, &win);
        
        CFRelease(app);
        
        if (result == kAXErrorSuccess) {
            new_window(L, win);
            return 1;
        }
    }
    
    lua_pushnil(L);
    return 1;
}

static id get_window_prop(AXUIElementRef win, NSString* propType, id defaultValue) {
    CFTypeRef _someProperty;
    if (AXUIElementCopyAttributeValue(win, (__bridge CFStringRef)propType, &_someProperty) == kAXErrorSuccess)
        return CFBridgingRelease(_someProperty);
    
    return defaultValue;
}

static BOOL set_window_prop(AXUIElementRef win, NSString* propType, id value) {
    if ([value isKindOfClass:[NSNumber class]]) {
        AXError result = AXUIElementSetAttributeValue(win, (__bridge CFStringRef)(propType), (__bridge CFTypeRef)(value));
        if (result == kAXErrorSuccess)
            return YES;
    }
    return NO;
}

/// window:title() -> string
/// Returns the title of the window (as UTF8).
static int window_title(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    NSString* title = get_window_prop(win, NSAccessibilityTitleAttribute, @"");
    lua_pushstring(L, [title UTF8String]);
    return 1;
}

/// window:subrole() -> string
/// Returns the subrole of the window, whatever that means.
static int window_subrole(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    NSString* str = get_window_prop(win, NSAccessibilitySubroleAttribute, @"");
    
    lua_pushstring(L, [str UTF8String]);
    return 1;
}

/// window:role() -> string
/// Returns the role of the window, whatever that means.
static int window_role(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    NSString* str = get_window_prop(win, NSAccessibilityRoleAttribute, @"");
    
    lua_pushstring(L, [str UTF8String]);
    return 1;
}

/// window:isstandard() -> bool
/// True if the window's subrole indicates it's 'a standard window'.
static int window_isstandard(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    NSString* subrole = get_window_prop(win, NSAccessibilitySubroleAttribute, @"");
    
    BOOL is_standard = [subrole isEqualToString: (__bridge NSString*)kAXStandardWindowSubrole];
    lua_pushboolean(L, is_standard);
    return 1;
}

/// window:topleft() -> point
/// The top-left corner of the window in absolute coordinates.
static int window_topleft(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    CFTypeRef positionStorage;
    AXError result = AXUIElementCopyAttributeValue(win, (CFStringRef)NSAccessibilityPositionAttribute, &positionStorage);
    
    CGPoint topLeft;
    if (result == kAXErrorSuccess) {
        if (!AXValueGetValue(positionStorage, kAXValueCGPointType, (void *)&topLeft)) {
//            NSLog(@"could not decode topLeft");
            topLeft = CGPointZero;
        }
    }
    else {
//        NSLog(@"could not get window topLeft");
        topLeft = CGPointZero;
    }
    
    if (positionStorage)
        CFRelease(positionStorage);
    
    hydra_pushpoint(L, topLeft);
    return 1;
}

/// window:size() -> size
/// The size of the window.
static int window_size(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    CFTypeRef sizeStorage;
    AXError result = AXUIElementCopyAttributeValue(win, (CFStringRef)NSAccessibilitySizeAttribute, &sizeStorage);
    
    CGSize size;
    if (result == kAXErrorSuccess) {
        if (!AXValueGetValue(sizeStorage, kAXValueCGSizeType, (void *)&size)) {
//            NSLog(@"could not decode topLeft");
            size = CGSizeZero;
        }
    }
    else {
//        NSLog(@"could not get window size");
        size = CGSizeZero;
    }
    
    if (sizeStorage)
        CFRelease(sizeStorage);
    
    hydra_pushsize(L, size);
    return 1;
}

/// window:settopleft(point)
/// Moves the window to the given point in absolute coordinate.
static int window_settopleft(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    NSPoint thePoint = hydra_topoint(L, 2);
    
    CFTypeRef positionStorage = (CFTypeRef)(AXValueCreate(kAXValueCGPointType, (const void *)&thePoint));
    AXUIElementSetAttributeValue(win, (CFStringRef)NSAccessibilityPositionAttribute, positionStorage);
    if (positionStorage)
        CFRelease(positionStorage);
    
    return 0;
}

/// window:setsize(size)
/// Resizes the window.
static int window_setsize(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    NSSize theSize = hydra_tosize(L, 2);
    
    CFTypeRef sizeStorage = (CFTypeRef)(AXValueCreate(kAXValueCGSizeType, (const void *)&theSize));
    AXUIElementSetAttributeValue(win, (CFStringRef)NSAccessibilitySizeAttribute, sizeStorage);
    if (sizeStorage)
        CFRelease(sizeStorage);
    
    return 0;
}

/// window:close() -> bool
/// Closes the window; returns whether it succeeded.
static int window_close(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    BOOL worked = NO;
    AXUIElementRef button = NULL;
    
    if (AXUIElementCopyAttributeValue(win, kAXCloseButtonAttribute, (CFTypeRef*)&button) != noErr) goto cleanup;
    if (AXUIElementPerformAction(button, kAXPressAction) != noErr) goto cleanup;
    
    worked = YES;
    
cleanup:
    if (button) CFRelease(button);
    
    lua_pushboolean(L, worked);
    return 1;
}

/// window:setfullscreen(bool) -> bool
/// Sets whether the window is full screen; returns whether it succeeded.
static int window_setfullscreen(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    CFBooleanRef befullscreen = lua_toboolean(L, 2) ? kCFBooleanTrue : kCFBooleanFalse;
    BOOL succeeded = (AXUIElementSetAttributeValue(win, CFSTR("AXFullScreen"), befullscreen) == noErr);
    lua_pushboolean(L, succeeded);
    return 1;
}

/// window:isfullscreen() -> bool or nil
/// Returns whether the window is full screen, or nil if asking that question fails.
static int window_isfullscreen(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    id isfullscreen = nil;
    CFBooleanRef fullscreen = kCFBooleanFalse;
    
    if (AXUIElementCopyAttributeValue(win, CFSTR("AXFullScreen"), (CFTypeRef*)&fullscreen) != noErr) goto cleanup;
    
    isfullscreen = @(CFBooleanGetValue(fullscreen));
    
cleanup:
    if (fullscreen) CFRelease(fullscreen);
    
    if (isfullscreen)
        lua_pushboolean(L, [isfullscreen boolValue]);
    else
        lua_pushnil(L);
    
    return 1;
}

/// window:minimize()
/// Minimizes the window.
static int window_minimize(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    set_window_prop(win, NSAccessibilityMinimizedAttribute, @YES);
    return 0;
}

/// window:unminimize()
/// Un-minimizes the window.
static int window_unminimize(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    set_window_prop(win, NSAccessibilityMinimizedAttribute, @NO);
    return 0;
}

/// window:isminimized() -> bool
/// True if the window is currently minimized in the dock.
static int window_isminimized(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    BOOL minimized = [get_window_prop(win, NSAccessibilityMinimizedAttribute, @(NO)) boolValue];
    lua_pushboolean(L, minimized);
    return 1;
}

// private function
// args: [win]
// ret: [pid]
static int window_pid(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    pid_t pid = 0;
    if (AXUIElementGetPid(win, &pid) == kAXErrorSuccess) {
        lua_pushnumber(L, pid);
        return 1;
    }
    else {
        return 0;
    }
}

/// window:application() -> app
/// Returns the app that the window belongs to.
static int window_application(lua_State* L) {
    if (window_pid(L)) {
        pid_t pid = lua_tonumber(L, -1);
        new_application(L, pid);
        return 1;
    }
    else {
        return 0;
    }
}

/// window:becomemain() -> bool
/// Make this window the main window of the given application; deos not implicitly focus the app.
static int window_becomemain(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    BOOL success = (AXUIElementSetAttributeValue(win, (CFStringRef)NSAccessibilityMainAttribute, kCFBooleanTrue) == kAXErrorSuccess);
    lua_pushboolean(L, success);
    return 1;
}

static int window__orderedwinids(lua_State* L) {
    lua_newtable(L);
    
    CFArrayRef wins = CGWindowListCreate(kCGWindowListOptionOnScreenOnly | kCGWindowListExcludeDesktopElements, kCGNullWindowID);
    
    for (int i = 0; i < CFArrayGetCount(wins); i++) {
        int winid = (int)CFArrayGetValueAtIndex(wins, i);
        
        lua_pushnumber(L, winid);
        lua_rawseti(L, -2, i+1);
    }
    
    CFRelease(wins);
    
    return 1;
}

/// window:id() -> number, sometimes nil
/// Returns a unique number identifying this window.
static int window_id(lua_State* L) {
    lua_settop(L, 1);
    AXUIElementRef win = hydra_window(L, 1);
    
    lua_getuservalue(L, 1);
    
    lua_getfield(L, -1, "id");
    if (lua_isnumber(L, -1))
        return 1;
    else
        lua_pop(L, 1);
    
    CGWindowID winid;
    AXError err = _AXUIElementGetWindow(win, &winid);
    if (err) {
        lua_pushnil(L);
        return 1;
    }
    
    // cache it
    lua_pushnumber(L, winid);
    lua_setfield(L, -2, "id");
    
    lua_pushnumber(L, winid);
    return 1;
}

static const luaL_Reg windowlib[] = {
    {"focusedwindow", window_focusedwindow},
    {"_orderedwinids", window__orderedwinids},
    
    {"title", window_title},
    {"subrole", window_subrole},
    {"role", window_role},
    {"isstandard", window_isstandard},
    {"topleft", window_topleft},
    {"size", window_size},
    {"settopleft", window_settopleft},
    {"setsize", window_setsize},
    {"minimize", window_minimize},
    {"unminimize", window_unminimize},
    {"isminimized", window_isminimized},
    {"pid", window_pid},
    {"application", window_application},
    {"becomemain", window_becomemain},
    {"id", window_id},
    {"close", window_close},
    {"setfullscreen", window_setfullscreen},
    {"isfullscreen", window_isfullscreen},
    
    {NULL, NULL}
};

int luaopen_window(lua_State* L) {
    luaL_newlib(L, windowlib);
    
    if (luaL_newmetatable(L, "window")) {
        lua_pushvalue(L, -2);
        lua_setfield(L, -2, "__index");
        
        lua_pushcfunction(L, window_gc);
        lua_setfield(L, -2, "__gc");
        
        lua_pushcfunction(L, window_eq);
        lua_setfield(L, -2, "__eq");
    }
    lua_pop(L, 1);
    
    return 1;
}

//
//  AppDelegate.m
//  ChromatismDemo
//
//  Created by Anviking on 2013-07-31.
//  Copyright (c) 2013 Anviking. All rights reserved.
//

#import "AppDelegate.h"
#import <Chromatism/Chromatism.h>

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    
    JLTextViewController *viewController = [[JLTextViewController alloc] init];
    UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:viewController];
    viewController.title = @"Chromatism";
    
    self.window.rootViewController = navigationController;
    self.window.backgroundColor = [UIColor whiteColor];
    [self.window makeKeyAndVisible];
    return YES;
}

- (void)applicationWillResignActive:(UIApplication *)application
{
    // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
    // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
}

- (void)applicationDidEnterBackground:(UIApplication *)application
{
    // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later. 
    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
}

/*
- (void)applicationWillEnterForeground:(UIApplication *)application
{
    // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.
}

- (void)applicationDidBecomeActive:(UIApplication *)application
{
    // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
}

- (void)applicationWillTerminate:(UIApplication *)application
{
    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
}
*/

@end

//
//  Tokenizer.m
//  iGitpad
//
//  Created by Johannes Lund on 2012-11-24.
//
//

//  This file builds upon the work of Kristian Kraljic
//
//  RegexHighlightView.m
//  Simple Objective-C Syntax Highlighter
//
//  Created by Kristian Kraljic on 30/08/12.
//  Copyright (c) 2012 Kristian Kraljic (dikrypt.com, ksquared.de). All rights reserved.
//
//  Permission is hereby granted, free of charge, to any person
//  obtaining a copy of this software and associated documentation
//  files (the "Software"), to deal in the Software without
//  restriction, including without limitation the rights to use,
//  copy, modify, merge, publish, distribute, sublicense, and/or
//  sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following
//  conditions:
//
//  The above copyright notice and this permission notice shall be
//  included in all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//  OTHER DEALINGS IN THE SOFTWARE.
//

#import "JLTokenizer.h"
#import "JLTextViewController.h" 
#import "JLScope.h"
#import "JLTokenPattern.h"
#import "Chromatism+Internal.h"

@interface JLTokenizer ()
@property (nonatomic, strong) NSOperationQueue *operationQueue;
@end

@implementation JLTokenizer

#pragma mark - Setup

- (id)init
{
    self = [super init];
    if (self) {
        self.operationQueue = [[NSOperationQueue alloc] init];
        self.operationQueue.maxConcurrentOperationCount = 1;
    }
    return self;
}

#pragma mark - NSTextStorageDelegate

- (void)textStorage:(NSTextStorage *)textStorage willProcessEditing:(NSTextStorageEditActions)editedMask range:(NSRange)editedRange changeInLength:(NSInteger)delta
{
    
}

- (void)textStorage:(NSTextStorage *)textStorage didProcessEditing:(NSTextStorageEditActions)editedMask range:(NSRange)editedRange changeInLength:(NSInteger)delta
{
    if (textStorage.editedMask == NSTextStorageEditedAttributes) return;
    [self tokenizeTextStorage:textStorage withScope:[self documentScopeForTokenizingTextStorage:textStorage inRange:editedRange]];
}

#pragma mark - NSLayoutManager delegeate

- (CGFloat)layoutManager:(NSLayoutManager *)layoutManager paragraphSpacingBeforeGlyphAtIndex:(NSUInteger)glyphIndex withProposedLineFragmentRect:(CGRect)rect
{
    return 0;
}

- (BOOL)layoutManager:(NSLayoutManager *)layoutManager shouldBreakLineByWordBeforeCharacterAtIndex:(NSUInteger)charIndex
{
    unichar character = [layoutManager.textStorage.string characterAtIndex:charIndex];
    if (character == '*') return NO;
    return YES;
}

#pragma mark - UITextViewDelegate

- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text
{
    if (![text isEqualToString:@"\n"]) return YES; // Something else than return
    
    // Return has been pressed, start the new line with as many tabs or white spaces as the previous one.
    NSString *prefixString = [@"\n" stringByAppendingString:[self prefixStringFromRange:range inTextView:textView]];
    
    unichar previousCharacter = [textView.text characterAtIndex:range.location - 1];
    if (self.intendator && [self.intendator respondsToSelector:@selector(indentationActionAfterReplacingTextInRange:replacementText:previousCharacter:textView:)]) {
        switch ([self indentationActionAfterReplacingTextInRange:range replacementText:text previousCharacter:previousCharacter textView:textView]) {
            case JLIndentationActionIncrease:
                prefixString = [prefixString stringByAppendingString:@"    "];
                break;
            case JLIndentationActionDecrease:
                if ([[prefixString substringFromIndex:prefixString.length - 4] isEqualToString:@"    "]) {
                    prefixString = [prefixString substringToIndex:prefixString.length - 4];
                }
                else if ([[prefixString substringFromIndex:prefixString.length - 1] isEqualToString:@"\t"]) {
                    prefixString = [prefixString substringToIndex:prefixString.length - 1];
                }
                break;
            case JLIndentationActionNone:
                break;
        }
    }

    
    [textView replaceRange:[self rangeWithRange:range inTextView:textView] withText:prefixString];
    return NO;
}


#pragma mark - Tokenizing

- (void)refreshTokenizationOfTextStorage:(NSTextStorage *)textStorage;
{
    [self tokenizeTextStorage:textStorage withScope:[self documentScopeForTokenizingTextStorage:textStorage inRange:NSMakeRange(0, textStorage.length)]];
}

- (JLScope *)documentScopeForTokenizingTextStorage:(NSTextStorage *)textStorage inRange:(NSRange)range
{
    JLScope *documentScope = [JLScope new];
    JLScope *lineScope = [JLScope new];
    
    [self prepareDocumentScope:documentScope];
    [self prepareLineScope:lineScope];
    
    [documentScope addSubscope:lineScope];
    
    [self clearColorAttributesInRange:range textStorage:textStorage];
    
    [documentScope setTextStorage:textStorage];
    [documentScope setSet:[NSMutableIndexSet indexSetWithIndexesInRange:NSMakeRange(0, textStorage.length)]];
    [lineScope setSet:[NSMutableIndexSet indexSetWithIndexesInRange:[textStorage.string lineRangeForRange:range]]];
    
    return documentScope;
}

- (void)tokenizeTextStorage:(NSTextStorage *)textStorage withScope:(JLScope *)scope
{
    //[textStorage beginEditing];
    [self.operationQueue addOperations:[[scope recursiveSubscopes] allObjects] waitUntilFinished:YES];
    //[textStorage endEditing];
}

#pragma mark - Synchronous Tokenization

- (void)tokenizeAttributedString:(NSMutableAttributedString *)string
{
    JLScope *scope = [self documentScopeForTokenizingTextStorage:(NSTextStorage *)string inRange:NSMakeRange(0, string.length)];
    [self.operationQueue addOperations:[[scope recursiveSubscopes] allObjects] waitUntilFinished:YES];
}

#pragma mark - Setup Token Patterns

- (void)prepareDocumentScope:(JLScope *)documentScope
{

}

- (void)prepareLineScope:(JLScope *)lineScope
{

}


#pragma mark - Symbolication

/*
- (void)symbolicate
{
    [self.scopes[PROJECT_CLASS_NAMES] setPattern:[NSString stringWithFormat:@"\\b(%@)\\b", [[self symbolsWithPattern:@"^@implementation (\\w+)" captureGroup:1] componentsJoinedByString:@"|"]]];
    [self.scopes[PROJECT_METHOD_NAMES] setPattern:[NSString stringWithFormat:@"\\b(%@)\\b", [[self symbolsWithPattern:@"^@property \\(.*?\\)\\s*\\w+[\\s*]+(\\w+);" captureGroup:1] componentsJoinedByString:@"|"]]];
}
*/

#pragma mark - Helpers

- (JLTokenPattern *)addToken:(NSString *)type withPattern:(NSString *)pattern andScope:(JLScope *)scope
{

    NSParameterAssert(type);
    NSParameterAssert(pattern);
    NSParameterAssert(scope);
    
    JLTokenPattern *token = [JLTokenPattern token:type withPattern:pattern andScope:scope];
    token.color = self.colors[type];
    
    return token;
}

- (JLTokenPattern *)addToken:(NSString *)type withKeywords:(NSString *)keywords andScope:(JLScope *)scope
{
    NSString *pattern = [NSString stringWithFormat:@"\\b(%@)\\b", [[keywords componentsSeparatedByString:@" "] componentsJoinedByString:@"|"]];
    return [self addToken:type withPattern:pattern andScope:scope];
}

- (NSMutableArray *)symbolsWithPattern:(NSString *)pattern captureGroup:(int)group textStorage:(NSTextStorage *)textStorage
{
    NSMutableArray *array = [NSMutableArray array];
    NSError *error = nil;
    NSRegularExpression *expression = [NSRegularExpression regularExpressionWithPattern:pattern options:NSRegularExpressionAnchorsMatchLines error:&error];
    [expression enumerateMatchesInString:textStorage.string options:0 range:NSMakeRange(0, textStorage.length) usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOL *stop) {
        [array addObject:[textStorage.string substringWithRange:[result rangeAtIndex:group]]];
    }];
    NSAssert(!error, @"%@",error);
    return array;
}

#pragma mark - Indentation

- (id <JLIndentation>)intendator
{
    if (!_intendator) {
        _intendator = self;
    }
    return _intendator;
}

- (JLIndentationAction)indentationActionAfterReplacingTextInRange:(NSRange)range replacementText:(NSString *)text previousCharacter:(unichar)character textView:(UITextView *)textView;
{
    if (character == '{') {
        return JLIndentationActionIncrease;
    } else if (character == '}') {
        return JLIndentationActionDecrease;
    } else {
        return JLIndentationActionNone;
    }
}

#pragma mark - Helpers

- (UITextRange *)rangeWithRange:(NSRange)range inTextView:(UITextView *)textView
{
    UITextPosition *beginning = textView.beginningOfDocument;
    UITextPosition *start = [textView positionFromPosition:beginning offset:range.location];
    UITextPosition *stop = [textView positionFromPosition:start offset:range.length];
    
    return [textView textRangeFromPosition:start toPosition:stop];
}

- (void)clearColorAttributesInRange:(NSRange)range textStorage:(NSTextStorage *)storage;
{
    [storage removeAttribute:NSForegroundColorAttributeName range:range];
    [storage addAttribute:NSForegroundColorAttributeName value:self.colors[JLTokenTypeText] range:range];
}

- (NSString *)prefixStringFromRange:(NSRange)range inTextView:(UITextView *)textView
{
    NSRange lineRange = [textView.text lineRangeForRange:range];
    NSRange prefixRange = [textView.text rangeOfString:@"[\\t| ]*" options:NSRegularExpressionSearch range:lineRange];
    return [textView.text substringWithRange:prefixRange];
}

@end


//
//  JLTextViewController.m
//  iGitpad
//
//  Created by Johannes Lund on 2013-06-13.
//  Copyright (c) 2013 Johannes Lund
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of
//  this software and associated documentation files (the "Software"), to deal in
//  the Software without restriction, including without limitation the rights to
//  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
//  the Software, and to permit persons to whom the Software is furnished to do so,
//  subject to the following conditions:

//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.

//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
//  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
//  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
//  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.//

#import "JLTextViewController.h"
#import "JLTokenizer.h"
#import "JLTokenizer.h"
#import "JLTextView.h"

@interface JLTextViewController ()
/// Only set from -initWithText: and directly set to nil in -loadView
@property (nonatomic, strong) NSString *defaultText;
@end

@implementation JLTextViewController

- (instancetype)initWithText:(NSString *)text
{
    self = [super init];
    if (self) {
        _defaultText = text;
    }
    return self;
}

- (void)loadView
{
    self.view = self.textView;
}

- (JLTextView *)textView
{
    if (!_textView) {
        JLTextView *textView = [[JLTextView alloc] initWithFrame:CGRectZero];
        textView.autoresizingMask = UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth;
        
        if (self.defaultText) {
            textView.text = self.defaultText;
            self.defaultText = nil;
        }
        
        [self setTextView:textView];
    }
    return _textView;
}
/*
- (JLTokenizer *)tokenizer
{
    return self.textView.syntaxTokenizer;
}
*/
/*
- (void)viewDidLoad
{
    [super viewDidLoad];
    
    self.view.backgroundColor = self.textView.backgroundColor;
    self.navigationController.navigationBar.translucent = TRUE;
    
    [self registerForKeyboardNotifications];
}
*/

/*
- (void)didReceiveMemoryWarning
{/*
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
    */
}
*/

#pragma mark - Content Insets and Keyboard

// Call this method somewhere in your view controller setup code.
- (void)registerForKeyboardNotifications
{
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(keyboardWasShown:)
                                                 name:UIKeyboardDidShowNotification object:nil];
    
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(keyboardWillBeHidden:)
                                                 name:UIKeyboardWillHideNotification object:nil];
    
}

// Called when the UIKeyboardDidShowNotification is sent.
- (void)keyboardWasShown:(NSNotification *)notification
{
    NSDictionary* info = [notification userInfo];
    UIScrollView *scrollView = self.textView;
    CGSize kbSize = [[info objectForKey:UIKeyboardFrameBeginUserInfoKey] CGRectValue].size;
    
    UIEdgeInsets contentInsets = scrollView.contentInset;
    contentInsets.bottom = kbSize.height;
    scrollView.contentInset = contentInsets;
    scrollView.scrollIndicatorInsets = contentInsets;
    
    CGPoint point = [self.textView caretRectForPosition:self.textView.selectedTextRange.start].origin;
    point.y = MIN(point.y, self.textView.frame.size.height - kbSize.height);
    
    CGRect aRect = self.view.frame;
    aRect.size.height -= kbSize.height;
    if (!CGRectContainsPoint(aRect, point) ) {
        
        CGRect rect = CGRectMake(point.x, point.y, 1, 1);
        rect.size.height = kbSize.height;
        rect.origin.y += kbSize.height;
        [self.textView scrollRectToVisible:rect animated:YES];
    }
}

// Called when the UIKeyboardWillHideNotification is sent
- (void)keyboardWillBeHidden:(NSNotification *)notification
{
    UIScrollView *scrollView = self.textView;
    UIEdgeInsets contentInsets = scrollView.contentInset;
    contentInsets.bottom = 0;
    scrollView.contentInset = contentInsets;
    scrollView.scrollIndicatorInsets = contentInsets;
    scrollView.contentInset = contentInsets;
    scrollView.scrollIndicatorInsets = contentInsets;
}

@end

//
//  JLTextViewController.h
//  iGitpad
//
//  Created by Johannes Lund on 2013-06-13.
//  Copyright (c) 2013 Johannes Lund
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of
//  this software and associated documentation files (the "Software"), to deal in
//  the Software without restriction, including without limitation the rights to
//  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
//  the Software, and to permit persons to whom the Software is furnished to do so,
//  subject to the following conditions:

//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.

//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
//  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
//  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
//  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.//

/*
#import <UIKit/UIKit.h>

@class JLTokenizer, JLTextView;

@interface JLTextViewController : UIViewController

- (instancetype)initWithText:(NSString *)text;

@property (nonatomic, strong) IBOutlet JLTextView *textView;

// Convenience property for self.textView.syntaxTokenizer
@property (nonatomic, weak, readonly) JLTokenizer *tokenizer;
@end
*/

//
//  AppDelegate.m
//  ChromatismDemo
//
//  Created by Anviking on 2013-07-31.
//  Copyright (c) 2013 Anviking. All rights reserved.
//

#import "AppDelegate.h"
#import <Chromatism/Chromatism.h>

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    
    JLTextViewController *viewController = [[JLTextViewController alloc] init];
    UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:viewController];
    viewController.title = @"Chromatism";
    
    self.window.rootViewController = navigationController;
    self.window.backgroundColor = [UIColor whiteColor];
    [self.window makeKeyAndVisible];
    return YES;
}

- (void)applicationWillResignActive:(UIApplication *)application
{
    // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
    // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
}

- (void)applicationDidEnterBackground:(UIApplication *)application
{
    // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later. 
    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
}

/*
- (void)applicationWillEnterForeground:(UIApplication *)application
{
    // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.
}

- (void)applicationDidBecomeActive:(UIApplication *)application
{
    // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
}

- (void)applicationWillTerminate:(UIApplication *)application
{
    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
}
*/

@end

//
//  Tokenizer.m
//  iGitpad
//
//  Created by Johannes Lund on 2012-11-24.
//
//

//  This file builds upon the work of Kristian Kraljic
//
//  RegexHighlightView.m
//  Simple Objective-C Syntax Highlighter
//
//  Created by Kristian Kraljic on 30/08/12.
//  Copyright (c) 2012 Kristian Kraljic (dikrypt.com, ksquared.de). All rights reserved.
//
//  Permission is hereby granted, free of charge, to any person
//  obtaining a copy of this software and associated documentation
//  files (the "Software"), to deal in the Software without
//  restriction, including without limitation the rights to use,
//  copy, modify, merge, publish, distribute, sublicense, and/or
//  sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following
//  conditions:
//
//  The above copyright notice and this permission notice shall be
//  included in all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//  OTHER DEALINGS IN THE SOFTWARE.
//

#import "JLTokenizer.h"
#import "JLTextViewController.h" 
#import "JLScope.h"
#import "JLTokenPattern.h"
#import "Chromatism+Internal.h"

@interface JLTokenizer ()
@property (nonatomic, strong) NSOperationQueue *operationQueue;
@end

@implementation JLTokenizer

#pragma mark - Setup

- (id)init
{
    self = [super init];
    if (self) {
        self.operationQueue = [[NSOperationQueue alloc] init];
        self.operationQueue.maxConcurrentOperationCount = 1;
    }
    return self;
}

#pragma mark - NSTextStorageDelegate

- (void)textStorage:(NSTextStorage *)textStorage willProcessEditing:(NSTextStorageEditActions)editedMask range:(NSRange)editedRange changeInLength:(NSInteger)delta
{
    
}

- (void)textStorage:(NSTextStorage *)textStorage didProcessEditing:(NSTextStorageEditActions)editedMask range:(NSRange)editedRange changeInLength:(NSInteger)delta
{
    if (textStorage.editedMask == NSTextStorageEditedAttributes) return;
    [self tokenizeTextStorage:textStorage withScope:[self documentScopeForTokenizingTextStorage:textStorage inRange:editedRange]];
}

#pragma mark - NSLayoutManager delegeate

- (CGFloat)layoutManager:(NSLayoutManager *)layoutManager paragraphSpacingBeforeGlyphAtIndex:(NSUInteger)glyphIndex withProposedLineFragmentRect:(CGRect)rect
{
    return 0;
}

- (BOOL)layoutManager:(NSLayoutManager *)layoutManager shouldBreakLineByWordBeforeCharacterAtIndex:(NSUInteger)charIndex
{
    unichar character = [layoutManager.textStorage.string characterAtIndex:charIndex];
    if (character == '*') return NO;
    return YES;
}

#pragma mark - UITextViewDelegate

- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text
{
    if (![text isEqualToString:@"\n"]) return YES; // Something else than return
    
    // Return has been pressed, start the new line with as many tabs or white spaces as the previous one.
    NSString *prefixString = [@"\n" stringByAppendingString:[self prefixStringFromRange:range inTextView:textView]];
    
    unichar previousCharacter = [textView.text characterAtIndex:range.location - 1];
    if (self.intendator && [self.intendator respondsToSelector:@selector(indentationActionAfterReplacingTextInRange:replacementText:previousCharacter:textView:)]) {
        switch ([self indentationActionAfterReplacingTextInRange:range replacementText:text previousCharacter:previousCharacter textView:textView]) {
            case JLIndentationActionIncrease:
                prefixString = [prefixString stringByAppendingString:@"    "];
                break;
            case JLIndentationActionDecrease:
                if ([[prefixString substringFromIndex:prefixString.length - 4] isEqualToString:@"    "]) {
                    prefixString = [prefixString substringToIndex:prefixString.length - 4];
                }
                else if ([[prefixString substringFromIndex:prefixString.length - 1] isEqualToString:@"\t"]) {
                    prefixString = [prefixString substringToIndex:prefixString.length - 1];
                }
                break;
            case JLIndentationActionNone:
                break;
        }
    }

    
    [textView replaceRange:[self rangeWithRange:range inTextView:textView] withText:prefixString];
    return NO;
}


#pragma mark - Tokenizing

- (void)refreshTokenizationOfTextStorage:(NSTextStorage *)textStorage;
{
    [self tokenizeTextStorage:textStorage withScope:[self documentScopeForTokenizingTextStorage:textStorage inRange:NSMakeRange(0, textStorage.length)]];
}

- (JLScope *)documentScopeForTokenizingTextStorage:(NSTextStorage *)textStorage inRange:(NSRange)range
{
    JLScope *documentScope = [JLScope new];
    JLScope *lineScope = [JLScope new];
    
    [self prepareDocumentScope:documentScope];
    [self prepareLineScope:lineScope];
    
    [documentScope addSubscope:lineScope];
    
    [self clearColorAttributesInRange:range textStorage:textStorage];
    
    [documentScope setTextStorage:textStorage];
    [documentScope setSet:[NSMutableIndexSet indexSetWithIndexesInRange:NSMakeRange(0, textStorage.length)]];
    [lineScope setSet:[NSMutableIndexSet indexSetWithIndexesInRange:[textStorage.string lineRangeForRange:range]]];
    
    return documentScope;
}

- (void)tokenizeTextStorage:(NSTextStorage *)textStorage withScope:(JLScope *)scope
{
    //[textStorage beginEditing];
    [self.operationQueue addOperations:[[scope recursiveSubscopes] allObjects] waitUntilFinished:YES];
    //[textStorage endEditing];
}

#pragma mark - Synchronous Tokenization

- (void)tokenizeAttributedString:(NSMutableAttributedString *)string
{
    JLScope *scope = [self documentScopeForTokenizingTextStorage:(NSTextStorage *)string inRange:NSMakeRange(0, string.length)];
    [self.operationQueue addOperations:[[scope recursiveSubscopes] allObjects] waitUntilFinished:YES];
}

#pragma mark - Setup Token Patterns

- (void)prepareDocumentScope:(JLScope *)documentScope
{

}

- (void)prepareLineScope:(JLScope *)lineScope
{

}


#pragma mark - Symbolication

/*
- (void)symbolicate
{
    [self.scopes[PROJECT_CLASS_NAMES] setPattern:[NSString stringWithFormat:@"\\b(%@)\\b", [[self symbolsWithPattern:@"^@implementation (\\w+)" captureGroup:1] componentsJoinedByString:@"|"]]];
    [self.scopes[PROJECT_METHOD_NAMES] setPattern:[NSString stringWithFormat:@"\\b(%@)\\b", [[self symbolsWithPattern:@"^@property \\(.*?\\)\\s*\\w+[\\s*]+(\\w+);" captureGroup:1] componentsJoinedByString:@"|"]]];
}
*/

#pragma mark - Helpers

- (JLTokenPattern *)addToken:(NSString *)type withPattern:(NSString *)pattern andScope:(JLScope *)scope
{

    NSParameterAssert(type);
    NSParameterAssert(pattern);
    NSParameterAssert(scope);
    
    JLTokenPattern *token = [JLTokenPattern token:type withPattern:pattern andScope:scope];
    token.color = self.colors[type];
    
    return token;
}

- (JLTokenPattern *)addToken:(NSString *)type withKeywords:(NSString *)keywords andScope:(JLScope *)scope
{
    NSString *pattern = [NSString stringWithFormat:@"\\b(%@)\\b", [[keywords componentsSeparatedByString:@" "] componentsJoinedByString:@"|"]];
    return [self addToken:type withPattern:pattern andScope:scope];
}

- (NSMutableArray *)symbolsWithPattern:(NSString *)pattern captureGroup:(int)group textStorage:(NSTextStorage *)textStorage
{
    NSMutableArray *array = [NSMutableArray array];
    NSError *error = nil;
    NSRegularExpression *expression = [NSRegularExpression regularExpressionWithPattern:pattern options:NSRegularExpressionAnchorsMatchLines error:&error];
    [expression enumerateMatchesInString:textStorage.string options:0 range:NSMakeRange(0, textStorage.length) usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOL *stop) {
        [array addObject:[textStorage.string substringWithRange:[result rangeAtIndex:group]]];
    }];
    NSAssert(!error, @"%@",error);
    return array;
}

#pragma mark - Indentation

- (id <JLIndentation>)intendator
{
    if (!_intendator) {
        _intendator = self;
    }
    return _intendator;
}

- (JLIndentationAction)indentationActionAfterReplacingTextInRange:(NSRange)range replacementText:(NSString *)text previousCharacter:(unichar)character textView:(UITextView *)textView;
{
    if (character == '{') {
        return JLIndentationActionIncrease;
    } else if (character == '}') {
        return JLIndentationActionDecrease;
    } else {
        return JLIndentationActionNone;
    }
}

#pragma mark - Helpers

- (UITextRange *)rangeWithRange:(NSRange)range inTextView:(UITextView *)textView
{
    UITextPosition *beginning = textView.beginningOfDocument;
    UITextPosition *start = [textView positionFromPosition:beginning offset:range.location];
    UITextPosition *stop = [textView positionFromPosition:start offset:range.length];
    
    return [textView textRangeFromPosition:start toPosition:stop];
}

- (void)clearColorAttributesInRange:(NSRange)range textStorage:(NSTextStorage *)storage;
{
    [storage removeAttribute:NSForegroundColorAttributeName range:range];
    [storage addAttribute:NSForegroundColorAttributeName value:self.colors[JLTokenTypeText] range:range];
}

- (NSString *)prefixStringFromRange:(NSRange)range inTextView:(UITextView *)textView
{
    NSRange lineRange = [textView.text lineRangeForRange:range];
    NSRange prefixRange = [textView.text rangeOfString:@"[\\t| ]*" options:NSRegularExpressionSearch range:lineRange];
    return [textView.text substringWithRange:prefixRange];
}

@end


//
//  JLTextViewController.m
//  iGitpad
//
//  Created by Johannes Lund on 2013-06-13.
//  Copyright (c) 2013 Johannes Lund
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of
//  this software and associated documentation files (the "Software"), to deal in
//  the Software without restriction, including without limitation the rights to
//  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
//  the Software, and to permit persons to whom the Software is furnished to do so,
//  subject to the following conditions:

//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.

//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
//  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
//  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
//  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.//

#import "JLTextViewController.h"
#import "JLTokenizer.h"
#import "JLTokenizer.h"
#import "JLTextView.h"

@interface JLTextViewController ()
/// Only set from -initWithText: and directly set to nil in -loadView
@property (nonatomic, strong) NSString *defaultText;
@end

@implementation JLTextViewController

- (instancetype)initWithText:(NSString *)text
{
    self = [super init];
    if (self) {
        _defaultText = text;
    }
    return self;
}

- (void)loadView
{
    self.view = self.textView;
}

- (JLTextView *)textView
{
    if (!_textView) {
        JLTextView *textView = [[JLTextView alloc] initWithFrame:CGRectZero];
        textView.autoresizingMask = UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth;
        
        if (self.defaultText) {
            textView.text = self.defaultText;
            self.defaultText = nil;
        }
        
        [self setTextView:textView];
    }
    return _textView;
}
/*
- (JLTokenizer *)tokenizer
{
    return self.textView.syntaxTokenizer;
}
*/
/*
- (void)viewDidLoad
{
    [super viewDidLoad];
    
    self.view.backgroundColor = self.textView.backgroundColor;
    self.navigationController.navigationBar.translucent = TRUE;
    
    [self registerForKeyboardNotifications];
}
*/

/*
- (void)didReceiveMemoryWarning
{/*
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
    */
}
*/

#pragma mark - Content Insets and Keyboard

// Call this method somewhere in your view controller setup code.
- (void)registerForKeyboardNotifications
{
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(keyboardWasShown:)
                                                 name:UIKeyboardDidShowNotification object:nil];
    
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(keyboardWillBeHidden:)
                                                 name:UIKeyboardWillHideNotification object:nil];
    
}

// Called when the UIKeyboardDidShowNotification is sent.
- (void)keyboardWasShown:(NSNotification *)notification
{
    NSDictionary* info = [notification userInfo];
    UIScrollView *scrollView = self.textView;
    CGSize kbSize = [[info objectForKey:UIKeyboardFrameBeginUserInfoKey] CGRectValue].size;
    
    UIEdgeInsets contentInsets = scrollView.contentInset;
    contentInsets.bottom = kbSize.height;
    scrollView.contentInset = contentInsets;
    scrollView.scrollIndicatorInsets = contentInsets;
    
    CGPoint point = [self.textView caretRectForPosition:self.textView.selectedTextRange.start].origin;
    point.y = MIN(point.y, self.textView.frame.size.height - kbSize.height);
    
    CGRect aRect = self.view.frame;
    aRect.size.height -= kbSize.height;
    if (!CGRectContainsPoint(aRect, point) ) {
        
        CGRect rect = CGRectMake(point.x, point.y, 1, 1);
        rect.size.height = kbSize.height;
        rect.origin.y += kbSize.height;
        [self.textView scrollRectToVisible:rect animated:YES];
    }
}

// Called when the UIKeyboardWillHideNotification is sent
- (void)keyboardWillBeHidden:(NSNotification *)notification
{
    UIScrollView *scrollView = self.textView;
    UIEdgeInsets contentInsets = scrollView.contentInset;
    contentInsets.bottom = 0;
    scrollView.contentInset = contentInsets;
    scrollView.scrollIndicatorInsets = contentInsets;
    scrollView.contentInset = contentInsets;
    scrollView.scrollIndicatorInsets = contentInsets;
}

@end

//
//  JLTextViewController.h
//  iGitpad
//
//  Created by Johannes Lund on 2013-06-13.
//  Copyright (c) 2013 Johannes Lund
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of
//  this software and associated documentation files (the "Software"), to deal in
//  the Software without restriction, including without limitation the rights to
//  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
//  the Software, and to permit persons to whom the Software is furnished to do so,
//  subject to the following conditions:

//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.

//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
//  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
//  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
//  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.//

/*
#import <UIKit/UIKit.h>

@class JLTokenizer, JLTextView;

@interface JLTextViewController : UIViewController

- (instancetype)initWithText:(NSString *)text;

@property (nonatomic, strong) IBOutlet JLTextView *textView;

// Convenience property for self.textView.syntaxTokenizer
@property (nonatomic, weak, readonly) JLTokenizer *tokenizer;
@end
*/

#import "helpers.h"
void new_application(lua_State* L, pid_t pid);

#define hydra_window(L, idx) *((AXUIElementRef*)luaL_checkudata(L, idx, "window"))

static int window_gc(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    CFRelease(win);
    return 0;
}

static int window_eq(lua_State* L) {
    AXUIElementRef winA = hydra_window(L, 1);
    AXUIElementRef winB = hydra_window(L, 2);
    lua_pushboolean(L, CFEqual(winA, winB));
    return 1;
}

extern AXError _AXUIElementGetWindow(AXUIElementRef, CGWindowID* out);
NSWindow* hydra_nswindow_for_accessibility_window(AXUIElementRef win) {
    CGWindowID winid;
    AXError err = _AXUIElementGetWindow(win, &winid);
    if (err) return nil;
    
    for (NSWindow* window in [NSApp windows]) {
        if ([window windowNumber] == winid)
            return window;
    }
    
    return nil;
}

void new_window(lua_State* L, AXUIElementRef win) {
    AXUIElementRef* winptr = lua_newuserdata(L, sizeof(AXUIElementRef));
    *winptr = win;
    
    luaL_getmetatable(L, "window");
    lua_setmetatable(L, -2);
    
    lua_newtable(L);
    lua_setuservalue(L, -2);
}

static AXUIElementRef system_wide_element() {
    static AXUIElementRef element;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        element = AXUIElementCreateSystemWide();
    });
    return element;
}

/// window.focusedwindow() -> window
/// Returns the focused window, or nil.
static int window_focusedwindow(lua_State* L) {
    CFTypeRef app;
    AXUIElementCopyAttributeValue(system_wide_element(), kAXFocusedApplicationAttribute, &app);
    
    if (app) {
        CFTypeRef win;
        AXError result = AXUIElementCopyAttributeValue(app, (CFStringRef)NSAccessibilityFocusedWindowAttribute, &win);
        
        CFRelease(app);
        
        if (result == kAXErrorSuccess) {
            new_window(L, win);
            return 1;
        }
    }
    
    lua_pushnil(L);
    return 1;
}

static id get_window_prop(AXUIElementRef win, NSString* propType, id defaultValue) {
    CFTypeRef _someProperty;
    if (AXUIElementCopyAttributeValue(win, (__bridge CFStringRef)propType, &_someProperty) == kAXErrorSuccess)
        return CFBridgingRelease(_someProperty);
    
    return defaultValue;
}

static BOOL set_window_prop(AXUIElementRef win, NSString* propType, id value) {
    if ([value isKindOfClass:[NSNumber class]]) {
        AXError result = AXUIElementSetAttributeValue(win, (__bridge CFStringRef)(propType), (__bridge CFTypeRef)(value));
        if (result == kAXErrorSuccess)
            return YES;
    }
    return NO;
}

/// window:title() -> string
/// Returns the title of the window (as UTF8).
static int window_title(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    NSString* title = get_window_prop(win, NSAccessibilityTitleAttribute, @"");
    lua_pushstring(L, [title UTF8String]);
    return 1;
}

/// window:subrole() -> string
/// Returns the subrole of the window, whatever that means.
static int window_subrole(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    NSString* str = get_window_prop(win, NSAccessibilitySubroleAttribute, @"");
    
    lua_pushstring(L, [str UTF8String]);
    return 1;
}

/// window:role() -> string
/// Returns the role of the window, whatever that means.
static int window_role(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    NSString* str = get_window_prop(win, NSAccessibilityRoleAttribute, @"");
    
    lua_pushstring(L, [str UTF8String]);
    return 1;
}

/// window:isstandard() -> bool
/// True if the window's subrole indicates it's 'a standard window'.
static int window_isstandard(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    NSString* subrole = get_window_prop(win, NSAccessibilitySubroleAttribute, @"");
    
    BOOL is_standard = [subrole isEqualToString: (__bridge NSString*)kAXStandardWindowSubrole];
    lua_pushboolean(L, is_standard);
    return 1;
}

/// window:topleft() -> point
/// The top-left corner of the window in absolute coordinates.
static int window_topleft(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    CFTypeRef positionStorage;
    AXError result = AXUIElementCopyAttributeValue(win, (CFStringRef)NSAccessibilityPositionAttribute, &positionStorage);
    
    CGPoint topLeft;
    if (result == kAXErrorSuccess) {
        if (!AXValueGetValue(positionStorage, kAXValueCGPointType, (void *)&topLeft)) {
//            NSLog(@"could not decode topLeft");
            topLeft = CGPointZero;
        }
    }
    else {
//        NSLog(@"could not get window topLeft");
        topLeft = CGPointZero;
    }
    
    if (positionStorage)
        CFRelease(positionStorage);
    
    hydra_pushpoint(L, topLeft);
    return 1;
}

/// window:size() -> size
/// The size of the window.
static int window_size(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    CFTypeRef sizeStorage;
    AXError result = AXUIElementCopyAttributeValue(win, (CFStringRef)NSAccessibilitySizeAttribute, &sizeStorage);
    
    CGSize size;
    if (result == kAXErrorSuccess) {
        if (!AXValueGetValue(sizeStorage, kAXValueCGSizeType, (void *)&size)) {
//            NSLog(@"could not decode topLeft");
            size = CGSizeZero;
        }
    }
    else {
//        NSLog(@"could not get window size");
        size = CGSizeZero;
    }
    
    if (sizeStorage)
        CFRelease(sizeStorage);
    
    hydra_pushsize(L, size);
    return 1;
}

/// window:settopleft(point)
/// Moves the window to the given point in absolute coordinate.
static int window_settopleft(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    NSPoint thePoint = hydra_topoint(L, 2);
    
    CFTypeRef positionStorage = (CFTypeRef)(AXValueCreate(kAXValueCGPointType, (const void *)&thePoint));
    AXUIElementSetAttributeValue(win, (CFStringRef)NSAccessibilityPositionAttribute, positionStorage);
    if (positionStorage)
        CFRelease(positionStorage);
    
    return 0;
}

/// window:setsize(size)
/// Resizes the window.
static int window_setsize(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    NSSize theSize = hydra_tosize(L, 2);
    
    CFTypeRef sizeStorage = (CFTypeRef)(AXValueCreate(kAXValueCGSizeType, (const void *)&theSize));
    AXUIElementSetAttributeValue(win, (CFStringRef)NSAccessibilitySizeAttribute, sizeStorage);
    if (sizeStorage)
        CFRelease(sizeStorage);
    
    return 0;
}

/// window:close() -> bool
/// Closes the window; returns whether it succeeded.
static int window_close(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    BOOL worked = NO;
    AXUIElementRef button = NULL;
    
    if (AXUIElementCopyAttributeValue(win, kAXCloseButtonAttribute, (CFTypeRef*)&button) != noErr) goto cleanup;
    if (AXUIElementPerformAction(button, kAXPressAction) != noErr) goto cleanup;
    
    worked = YES;
    
cleanup:
    if (button) CFRelease(button);
    
    lua_pushboolean(L, worked);
    return 1;
}

/// window:setfullscreen(bool) -> bool
/// Sets whether the window is full screen; returns whether it succeeded.
static int window_setfullscreen(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    CFBooleanRef befullscreen = lua_toboolean(L, 2) ? kCFBooleanTrue : kCFBooleanFalse;
    BOOL succeeded = (AXUIElementSetAttributeValue(win, CFSTR("AXFullScreen"), befullscreen) == noErr);
    lua_pushboolean(L, succeeded);
    return 1;
}

/// window:isfullscreen() -> bool or nil
/// Returns whether the window is full screen, or nil if asking that question fails.
static int window_isfullscreen(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    id isfullscreen = nil;
    CFBooleanRef fullscreen = kCFBooleanFalse;
    
    if (AXUIElementCopyAttributeValue(win, CFSTR("AXFullScreen"), (CFTypeRef*)&fullscreen) != noErr) goto cleanup;
    
    isfullscreen = @(CFBooleanGetValue(fullscreen));
    
cleanup:
    if (fullscreen) CFRelease(fullscreen);
    
    if (isfullscreen)
        lua_pushboolean(L, [isfullscreen boolValue]);
    else
        lua_pushnil(L);
    
    return 1;
}

/// window:minimize()
/// Minimizes the window.
static int window_minimize(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    set_window_prop(win, NSAccessibilityMinimizedAttribute, @YES);
    return 0;
}

/// window:unminimize()
/// Un-minimizes the window.
static int window_unminimize(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    set_window_prop(win, NSAccessibilityMinimizedAttribute, @NO);
    return 0;
}

/// window:isminimized() -> bool
/// True if the window is currently minimized in the dock.
static int window_isminimized(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    BOOL minimized = [get_window_prop(win, NSAccessibilityMinimizedAttribute, @(NO)) boolValue];
    lua_pushboolean(L, minimized);
    return 1;
}

// private function
// args: [win]
// ret: [pid]
static int window_pid(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    pid_t pid = 0;
    if (AXUIElementGetPid(win, &pid) == kAXErrorSuccess) {
        lua_pushnumber(L, pid);
        return 1;
    }
    else {
        return 0;
    }
}

/// window:application() -> app
/// Returns the app that the window belongs to.
static int window_application(lua_State* L) {
    if (window_pid(L)) {
        pid_t pid = lua_tonumber(L, -1);
        new_application(L, pid);
        return 1;
    }
    else {
        return 0;
    }
}

/// window:becomemain() -> bool
/// Make this window the main window of the given application; deos not implicitly focus the app.
static int window_becomemain(lua_State* L) {
    AXUIElementRef win = hydra_window(L, 1);
    
    BOOL success = (AXUIElementSetAttributeValue(win, (CFStringRef)NSAccessibilityMainAttribute, kCFBooleanTrue) == kAXErrorSuccess);
    lua_pushboolean(L, success);
    return 1;
}

static int window__orderedwinids(lua_State* L) {
    lua_newtable(L);
    
    CFArrayRef wins = CGWindowListCreate(kCGWindowListOptionOnScreenOnly | kCGWindowListExcludeDesktopElements, kCGNullWindowID);
    
    for (int i = 0; i < CFArrayGetCount(wins); i++) {
        int winid = (int)CFArrayGetValueAtIndex(wins, i);
        
        lua_pushnumber(L, winid);
        lua_rawseti(L, -2, i+1);
    }
    
    CFRelease(wins);
    
    return 1;
}

/// window:id() -> number, sometimes nil
/// Returns a unique number identifying this window.
static int window_id(lua_State* L) {
    lua_settop(L, 1);
    AXUIElementRef win = hydra_window(L, 1);
    
    lua_getuservalue(L, 1);
    
    lua_getfield(L, -1, "id");
    if (lua_isnumber(L, -1))
        return 1;
    else
        lua_pop(L, 1);
    
    CGWindowID winid;
    AXError err = _AXUIElementGetWindow(win, &winid);
    if (err) {
        lua_pushnil(L);
        return 1;
    }
    
    // cache it
    lua_pushnumber(L, winid);
    lua_setfield(L, -2, "id");
    
    lua_pushnumber(L, winid);
    return 1;
}

static const luaL_Reg windowlib[] = {
    {"focusedwindow", window_focusedwindow},
    {"_orderedwinids", window__orderedwinids},
    
    {"title", window_title},
    {"subrole", window_subrole},
    {"role", window_role},
    {"isstandard", window_isstandard},
    {"topleft", window_topleft},
    {"size", window_size},
    {"settopleft", window_settopleft},
    {"setsize", window_setsize},
    {"minimize", window_minimize},
    {"unminimize", window_unminimize},
    {"isminimized", window_isminimized},
    {"pid", window_pid},
    {"application", window_application},
    {"becomemain", window_becomemain},
    {"id", window_id},
    {"close", window_close},
    {"setfullscreen", window_setfullscreen},
    {"isfullscreen", window_isfullscreen},
    
    {NULL, NULL}
};

int luaopen_window(lua_State* L) {
    luaL_newlib(L, windowlib);
    
    if (luaL_newmetatable(L, "window")) {
        lua_pushvalue(L, -2);
        lua_setfield(L, -2, "__index");
        
        lua_pushcfunction(L, window_gc);
        lua_setfield(L, -2, "__gc");
        
        lua_pushcfunction(L, window_eq);
        lua_setfield(L, -2, "__eq");
    }
    lua_pop(L, 1);
    
    return 1;
}



